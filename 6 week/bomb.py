"""
Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки.
Известно, что все n селений Тридесятой области находятся вдоль одной прямой дороги. Вдоль дороги
также расположены m бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.

Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее, необходимо для каждого селения
определить ближайшее к нему бомбоубежище.

Формат ввода
В первой строке вводится число n - количество селений (1 <= n <= 100000). Вторая строка содержит
n различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го селения.
В третьей строке входных данных задается число m - количество бомбоубежищ (1 <= m <= 100000).
Четвертая строка содержит m различных целых чисел, i-е из этих чисел задает расстояние от начала
дороги до i-го бомбоубежища. Все расстояния положительны и не превышают 10⁹. Селение и убежище
могут располагаться в одной точке.

Формат вывода
Выведите  n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища. Бомбоубежища
пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.

Указание
Создайте список кортежей из пар (позиция селения, его номер в исходном списке), а также аналогичный
список для бомбоубежищ. Отсортируйте эти списки.
Перебирайте селения в порядке возрастания.
Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо выбрать ближайшее.
При переходе к следующему селению не обязательно искать ближайшее бомбоубежище с самого начала.
Его можно искать начиная с позиции, найденной для предыдущего города. Аналогично, не нужно искать
подходящее бомбоубежище до конца списка бомбоубежищ: достаточно найти самое близкое. Если Вы неэффективно
реализуете эту часть, то решение тесты не пройдет.
Для хранения ответа используйте список, где индекс будет номером селения, а по этому индексу будет
запоминаться номер бомбоубежища.
"""


def sort_list(sl):
    return sl[0]


n, n1 = int(input()), list(map(int, input().split()))
m, m1 = int(input()), list(map(int, input().split()))
for i in range(n):
    n1[i] = (n1[i], i)
for i in range(m):
    m1[i] = (m1[i], i + 1)
n1.sort()
m1.sort()
shelter_list = []
mm = 0
for i in range(len(n1)):
    m_min = m1[-1][0] if m1[-1][0] > n1[i][0] else n1[i][0]
    while mm < len(m1) and abs(n1[i][0] - m1[mm][0]) < m_min:
        m_min = abs(n1[i][0] - m1[mm][0])
        mm += 1
    mm -= 1
    shelter_list.append((n1[i][1], m1[mm][1]))
print(*[i[1] for i in sorted(shelter_list, key=sort_list)])


# amount_towns = int(input())
# towns = list(enumerate(map(int, input().split()[:amount_towns]), 1))
# amount_shelters = int(input())
# shelters = list(enumerate(map(int, input().split()[:amount_shelters]), 1))
# towns.sort(key=lambda k: k[1])
# shelters.sort(key=lambda k: k[1])
# index = 0
# result = []
# for town in towns:
#     while (index + 1 < amount_shelters and abs(
#             town[1] - shelters[index][1]) > abs(
#             town[1] - shelters[index + 1][1])):
#         index += 1
#     else:
#         result.append([town[0], shelters[index][0]])
# result.sort()
# for i in result:
#     print(i[1], end=' ')


# totalCity = int(input())
# city = list(map(int, input().split()))
# totalShelter = int(input())
# shelter = list(map(int, input().split()))
# print(*[shelter.index(min(shelter, key=lambda x: abs(c-x))) + 1 for c in city])
